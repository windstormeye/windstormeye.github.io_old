<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="也就骑个车，顺便写点码，再去看看景"><title>从实际问题看 SwiftUI 和 Combine 编程 | PJHubs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从实际问题看 SwiftUI 和 Combine 编程</h1><a id="logo" href="/.">PJHubs</a><p class="description">也就骑个车，顺便写点码，再去看看景</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa undefined"> 文章</i></a><a href="/archives/"><i class="fa undefined"> 总览</i></a><a href="/photograph/"><i class="fa undefined"> 摄影</i></a><a href="/about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从实际问题看 SwiftUI 和 Combine 编程</h1><div class="post-meta">2019-11-09</div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 | 前言"></a>0x00 | 前言</h2><p>假设大家已对 Swift 语法有基本了解，并且已经上手体验过。虽在工作中可能并不会立即介入 SwiftUI 和 Combine，但通过对这两个框架的学习和使用可以从侧面给我们提供一个优化的思路，从以往「流程化」和「命令式」的编程思维中转变出来，提升开发效率。</p>
<p>此次分享在于快速对 SwiftUI 和 Combine 框架有一个基本认识，通过一个常规业务 demo 来验证 SwiftUI 和 Combine 提升效率的可能性，分享我在学习 SwiftUI 和 Combine 遇到问题和值得开心的地方。</p>
<h2 id="0x01-SwiftUI"><a href="#0x01-SwiftUI" class="headerlink" title="0x01 | SwiftUI"></a>0x01 | SwiftUI</h2><h3 id="1-SwiftUI-是什么？"><a href="#1-SwiftUI-是什么？" class="headerlink" title="1. SwiftUI 是什么？"></a>1. SwiftUI 是什么？</h3><ul>
<li><del>指令式编程</del> 响应式编程。</li>
<li>基于 <code>UIKit</code>、<code>Core Graphics</code>、<code>Core Text</code> 等系统框架封装了完整而优美的 DSL。</li>
<li>Combine 响应式编程框架和函数式编程思想直接驱动了 SwiftUI 中的数据流向。</li>
</ul>
<p><img src="https://i.loli.net/2019/11/09/GPgBCqTURvI8uor.png"></p>
<ul>
<li>提供了一套通用的语法和基础数据类型，抹平 Apple 自家平台差异性，降低同生态跨端难度。</li>
<li>抛弃 <code>ViewController</code> 概念。</li>
<li>在 API 层面上，有 RAC 链式调用的影子和 Combine 的强依赖实现。</li>
</ul>
<h3 id="2-Combine-是什么？"><a href="#2-Combine-是什么？" class="headerlink" title="2. Combine 是什么？"></a>2. Combine 是什么？</h3><ul>
<li>SwiftUI 中处理数据的本体，响应式框架。</li>
<li>提供给 SwiftUI 中与数据源双向绑定的能力。</li>
<li>数据流式处理「链式」调用。与 SwiftUI 的「链式」组织 UI 不同，SwiftUI 是通过链式调用构造出一个确定的单一对象（语法糖），但 Combine 的每一次链式调用都会生成一个新的源数据。</li>
</ul>
<h2 id="0x02-实现一个-Context-Menu"><a href="#0x02-实现一个-Context-Menu" class="headerlink" title="0x02 | 实现一个 Context Menu"></a>0x02 | 实现一个 Context Menu</h2><p><img src="https://i.loli.net/2019/11/09/GgvzAkcDW4LtMjm.png" alt="Context Menu"></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h3 id="菜单容器"><a href="#菜单容器" class="headerlink" title="菜单容器"></a>菜单容器</h3><p>「更多菜单」是一个几乎所有 App 里都会去实现的一个组件，其承担了非主业务，但又十分重要的二级工具类业务入口。如果通过常规的 <code>UIKit</code> 的思路去做，大致的实现思路是这样的：</p>
<ol>
<li>创建一个 <code>UIWindow</code> 或 <code>UIViewController</code>，作为菜单视图的容器；</li>
<li>通过 <code>UITableView</code> 或循环组件的方式创建出具体的菜单视图；</li>
<li>视图关系建立及菜单点击事件跳转逻辑回调完善。</li>
</ol>
<p>如果只想用 SwiftUI 去实现的化，在 SwiftUI 万物皆 <code>View</code>，没有 <code>ViewController</code> 的概念，所以这里的容器就回落到了 <code>View</code> 身上。包装一个视图容器，可能会是这样的：·</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MASSquareMenuView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">            .frame(minWidth: <span class="type">UIScreen</span>.main.bounds.width, </span><br><span class="line">                   minHeight: <span class="type">UIScreen</span>.main.bounds.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MASSquareMenuView</code> 充当了底层的 <code>ViewController</code> 角色。<code>View</code> 实际上是个结构体。如果 <code>body</code> 里返回不确定的类型，DSL 解析会失败，例如同时返回两个 <code>View</code>，通过 <code>if-else</code> 判断来返回不同的 <code>View</code>，这种情况会被拒绝执行。如果我们就是想通过一个标识位去判断当前要返回的到底是什么视图，需要使用 <code>@State</code> 关键词修饰的一个变量去操作。</p>
<h4 id="菜单-Cell-容器"><a href="#菜单-Cell-容器" class="headerlink" title="菜单 Cell 容器"></a>菜单 Cell 容器</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MASSquareHostView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="type">MASSquareMenuView</span> &#123;</span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>「链式调用的过程」被称为是 <code>SwiftUI</code> 中 <code>View</code> 的 <code>modifier</code>，每个 <code>modifier</code> 的调用结束后，返回给下一个 <code>modifier</code> 有两种情况：第一种情况只是对 <code>View</code>（如 <code>Text</code>）的 <code>font</code> 等与布局无关的方法，返回给下一个 <code>modifier</code> 相同类型的 <code>View</code>；第二种情况对 <code>View</code> 的布局产生了修改，如调用了 <code>padding</code> 等方法，返回给下一个链式调用的 <code>modifier</code> 是一个重新包装过的全新 <code>View</code>。</p>
<p>其实我觉得这跟之前用的链式调用库从概念上是一样的道理，有些链式方法的调用必须是依赖于某些方法的先执行，比如自定义 <code>Image</code> 这个标签的大小，必须先设置 <code>resizeable</code> 才能设置 <code>frame</code>，否则失效。</p>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>SwiftUI 的 API 设计哲学，强迫我去思考对外公开的组件所提供的定制化功能，之前跟 mentor 讨论过，类似这种 <code>ContextMenu</code> 是封装成一个 UI 组件还是一个业务组件，最后决定还是把这个菜单组件做成一个 UI 组件。</p>
<p>「更多菜单」的数据源经过调整，最终写出了一个基本符合 SwiftUI 风格的 API，基本符合是因为多了一个烦人的 <code>Group</code>，之前已经说过，SwiftUI 不接受多个视图返回，如果确实要返回多个视图的「组合视图」，需要手动对这些视图使用 <code>Group</code> 包装成一个 <code>View</code> 进行返回。</p>
<p>引发一个新的问题，怎么接收一组 <code>View</code>，通过对一个组件传递一串 <code>View</code> 来完全自定义菜单组件里的内容，使用 <code>UIKit</code> 的话我可能会这么做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PJPickerView</span>.showPickerView(viewModel: &#123;</span><br><span class="line">    <span class="variable">$0</span>.titleString <span class="operator">=</span> <span class="string">&quot;感情状态&quot;</span></span><br><span class="line">    <span class="variable">$0</span>.pickerType <span class="operator">=</span> .custom</span><br><span class="line">    <span class="variable">$0</span>.dataArray <span class="operator">=</span> [[<span class="string">&quot;单身&quot;</span>, <span class="string">&quot;约会中&quot;</span>, <span class="string">&quot;已婚&quot;</span>]]</span><br><span class="line">&#125;) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] finalString <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.loveTextField.text <span class="operator">=</span> finalString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/11/10/Ii59dkpazWt7BTV.png"></p>
<p>但在 SwiftUI 中，因目前版本（beta 7）受限于不支持返回不确定的内容，因此，我的设计为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MASSquareMenuView</span>(isShowMenu: <span class="keyword">self</span>.<span class="variable">$showingMenuView</span>) &#123;</span><br><span class="line">    <span class="type">Group</span> &#123;</span><br><span class="line">        <span class="type">MASSquareMenuCell</span>(itemName: <span class="string">&quot;笔记&quot;</span>, </span><br><span class="line">                          itemImageName: <span class="string">&quot;square.and.pencil&quot;</span>) &#123;</span><br><span class="line">            <span class="type">FirstView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MASSquareMenuCell</span>(itemName: <span class="string">&quot;广场&quot;</span>, </span><br><span class="line">                          itemImageName: <span class="string">&quot;burst&quot;</span>) &#123;</span><br><span class="line">            <span class="type">SecondView</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>itemName</code> 和 <code>itemImageName</code> 均可通过 <code>ForEach</code> 来完成，目前还没找到一个可以完成动态跳转的比较好的方式。</p>
<h4 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h4><p>如何把多个子 <code>View</code> 通过以上类似这种相对优雅的方式进行视图组合？我的这种封装方法思想来源于 <code>List</code> 系统组件的使用方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">List</span> &#123;</span><br><span class="line">    <span class="comment">// PJPostView(post: post)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ForEach</span>(posts) &#123; post <span class="keyword">in</span></span><br><span class="line">        <span class="type">PJPostView</span>(post: post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看 <code>List</code> 这个系统组件的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, OSX <span class="number">10.15</span>, <span class="keyword">tvOS</span> <span class="number">13.0</span>, <span class="keyword">watchOS</span> <span class="number">6.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">List</span>&lt;<span class="title class_">SelectionValue</span>, <span class="title class_">Content</span>&gt; : <span class="title class_">View</span> <span class="title class_">where</span> <span class="title class_">SelectionValue</span> : <span class="title class_">Hashable</span>, <span class="title class_">Content</span> : <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">watchOS</span>, unavailable)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">selection</span>: <span class="type">Binding</span>&lt;<span class="type">Set</span>&lt;<span class="type">SelectionValue</span>&gt;&gt;?, <span class="meta">@ViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">Content</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">watchOS</span>, unavailable)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">selection</span>: <span class="type">Binding</span>&lt;<span class="type">SelectionValue</span>?&gt;?, <span class="meta">@ViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">Content</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Body</span> <span class="operator">=</span> <span class="keyword">some</span> <span class="type">View</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有一个全新的关键词 <code>@ViewBuilder</code>，要求被 <code>@ViewBuilder</code> 修饰的 <code>content</code> 闭包返回的是个 <code>Content</code>。<code>Content</code> 的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, OSX <span class="number">10.15</span>, <span class="keyword">tvOS</span> <span class="number">13.0</span>, <span class="keyword">watchOS</span> <span class="number">6.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Body</span> : <span class="type">View</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="keyword">Self</span>.<span class="type">Content</span>) -&gt; <span class="keyword">Self</span>.<span class="type">Body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>content</code> 里的可以被「包含」的对象，只要是 <code>View</code> 类型即可，这一点很完美，但 <code>@ViewBuilder</code> 是什么？文档中的定义为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, OSX <span class="number">10.15</span>, <span class="keyword">tvOS</span> <span class="number">13.0</span>, <span class="keyword">watchOS</span> <span class="number">6.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="meta">@_functionBuilder</span> <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">ViewBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Builds an empty view from an block containing no statements, `&#123; &#125;`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildBlock</span>() -&gt; <span class="type">EmptyView</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Passes a single view written as a child view (e..g, `&#123; Text(&quot;Hello&quot;) &#125;`) through</span></span><br><span class="line">    <span class="comment">/// unmodified.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">buildBlock</span>&lt;<span class="type">Content</span>&gt;(<span class="keyword">_</span> <span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="type">Content</span> <span class="keyword">where</span> <span class="type">Content</span> : <span class="type">View</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看出了点端倪，通过 <code>@ViewBubilder</code> 修饰的 <code>View</code> 可以接收多个组合视图，从官方文档中，我们可以得知最多同时单个组件可承载的最大子组件数为 10 个。如果超过 10 个子组件，官方推荐的做法是再抽象进行封装成一个新的组件。</p>
<p><img src="https://i.loli.net/2019/11/11/A2eRycMEl4bsQdp.png"></p>
<p>大致的菜单 Cell 实现细节为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MASSquareMenuView</span>&lt;<span class="title class_">Content</span>: <span class="title class_">View</span>&gt;: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isShowMenu: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> content: () -&gt; <span class="type">Content</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="keyword">self</span>.content()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个 <code>MunuView</code> 初始化的时候，不给 <code>init</code> 方法，补齐 <code>content</code>，并且因为在 Swift 5.x 中最后一个闭包可省略，这就出现了之前的 API 格式。在封装 SwiftUI 组件的适合，可以不用一开始就着手封装，而是先「一锅端」，最好再利用 Xcode 11 提供的快捷操作，直接把位于一个上下文中的组件进行「一键抽离」。</p>
<h2 id="0x03-Combine-与-CoreData"><a href="#0x03-Combine-与-CoreData" class="headerlink" title="0x03 | Combine 与 CoreData"></a>0x03 | Combine 与 CoreData</h2><p>这里引入 <code>CoreData</code> 的意义只是能够给了一个相对稳定的数据来源，目前暂时还未结合网络请求进行验证。</p>
<p>这个例子想要完成的事情有：</p>
<ul>
<li>在「弹出框」中输入文本内容；</li>
<li>在「首页」展示输入的所有内容；</li>
<li>提供检索；</li>
<li><code>CloudKit</code> 备份。</li>
</ul>
<p><img src="https://i.loli.net/2019/11/11/AoV2g1SCbeRB9lk.png" alt="首页"></p>
<p><img src="https://i.loli.net/2019/11/11/zVZH9XC46SOGfQ8.png" alt="输入"></p>
<p>实话实说，完成这整套无缝的逻辑下来，花了不少时间。主要的时间耗费在理解和适应 SwiftUI 与 Combine 之间的联合关系，经常在思考如何合理有效的组织各个数据源去控制组件的交互。其中一定要死死握住的就是「单一数据源」，把能够引发某个组件产生某种行为的源头限制在同一个数据对象本身。</p>
<p>其中，最为常用的三个状态修饰符为：</p>
<ul>
<li><code>@State</code>；</li>
<li><code>@Binding</code>；</li>
<li><code>@ObservedObject</code>。</li>
</ul>
<p>在这个例子中的使用方式为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingSheet <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ObservedObject</span> <span class="keyword">var</span> aritcleManager <span class="operator">=</span> <span class="type">AritcleManager</span>()</span><br></pre></td></tr></table></figure>

<p>使用 <code>@State</code> 来修饰 <code>showingSheet</code> 变量作为控制「输入框」是否弹出的标识位，使用 <code>@Binding</code> 来修饰 <code>text</code> 从「弹出框」中<strong>引用</strong>出用户输入的内容，使用 <code>@ObservedObject</code> 修饰 <code>aritcleManager</code> 对象，其作为连接首页数据交互的中枢。</p>
<p><code>@State</code> 的作用本质上非常像「自动合成」了被修饰变量的 <code>setter</code> 和 <code>getter</code> 方法，我们如果直接使用 <code>didSet</code>&#x2F;<code>willSet</code> 监听方法，也确实能够完成 <code>@State</code> 做的事情，这部分事情之前也确实有人做过。在 SwiftUI 中每当去触发一个 <code>@State</code> 修饰变量的 <code>setter</code> 方法时，<code>body</code> 属性都会根据新值跑一遍 diff，找出需要被刷新的视图，并生成新的视图进行刷新。其&#x2F; 所修饰的属性访问，只能发生在当前 <code>body</code> 或者 <code>body</code> 的作用范围内，不能在外部修改 <code>@State</code> 的值。</p>
<p><code>@Binding</code> 作用可以说与 <code>@State</code> 大同小异，最大的区别在于在 A 层级下进行操作的使用 <code>@State</code> 修饰的属性，无法传递到 A 的子层级，因为进行的是「值引用」，而改为使用 <code>@Binding</code> 修饰，把该属性变为引用语义。</p>
<p>如果我们有一个更为特殊的组件（比如，各种「设置」类组件），可以对父组件的某个关键属性使用 <code>@EnvironmentObject</code> 关键词进行修饰， 其可做到该父组件的所有子视图均可获取到该值，降低重复操作，且子视图可以不用再声明该属性，只需要在父组件在创建时创建。</p>
<p><code>AritcleManager</code> 作为首页数据处理的中枢，其承担了「输入」和「搜索」两个任务，而为了保证单一数据源的理念，引入了 <code>@Published</code> 修饰其内部持有的真正数据源 <code>articles</code>，每当 <code>articles</code> 发生改变时，都向外部订阅者发布通知。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AritcleManager</span>: <span class="title class_">NSObject</span>, <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// 写法 1</span></span><br><span class="line">    <span class="keyword">var</span> objectWillChange: <span class="type">ObservableObjectPublisher</span> <span class="operator">=</span> <span class="type">ObservableObjectPublisher</span>()</span><br><span class="line">    <span class="comment">// 写法 2</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> articles: [<span class="type">Article</span>] <span class="operator">=</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 CoreData 的交互使用了 <code>NSFetchedResultsController</code> 来进行，这部分可以替换成网络交互部分的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: NSFetchedResultsControllerDelegate</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">AritcleManager</span>: <span class="title class_">NSFetchedResultsControllerDelegate</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">controllerDidChangeContent</span>(<span class="keyword">_</span> <span class="params">controller</span>: <span class="type">NSFetchedResultsController</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;) &#123;</span><br><span class="line">        articles <span class="operator">=</span> controller.fetchedObjects <span class="keyword">as!</span> [<span class="type">Article</span>]</span><br><span class="line">        <span class="comment">// 写法 2 可省略，不需要主动触发发布</span></span><br><span class="line">        objectWillChange.send()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在「首页」中的初始化和交互操作为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MASSquareHostView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> aritcleManager <span class="operator">=</span> <span class="type">AritcleManager</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">MASSquareListView</span>(articles: <span class="keyword">self</span>.<span class="variable">$aritcleManager</span>.articles,</span><br><span class="line">                              showingSheet: <span class="keyword">self</span>.<span class="variable">$showingSheet</span>) &#123;</span><br><span class="line">                                <span class="keyword">self</span>.aritcleManager.articles[<span class="variable">$0</span>].delete()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从写法 1 发现了一个奇怪的地方（写法 2 可暂时理解为是写法 1 的语法糖）， <code>ObservableObjectPublisher</code> 是怎么做到「自动监听」的呢？来看看其定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, OSX <span class="number">10.15</span>, <span class="keyword">tvOS</span> <span class="number">13.0</span>, <span class="keyword">watchOS</span> <span class="number">6.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObservableObjectPublisher</span> : <span class="title class_">Publisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Output</span> <span class="operator">=</span> <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Failure</span> <span class="operator">=</span> <span class="type">Never</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">receive</span>&lt;<span class="type">S</span>&gt;(<span class="params">subscriber</span>: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Subscriber</span>, <span class="type">S</span>.<span class="type">Failure</span> <span class="operator">==</span> <span class="type">ObservableObjectPublisher</span>.<span class="type">Failure</span>, <span class="type">S</span>.<span class="type">Input</span> <span class="operator">==</span> <span class="type">ObservableObjectPublisher</span>.<span class="type">Output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">send</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ObservableObjectPublisher</code> 是继承自 <code>Publisher</code> 类，而 <code>Publisher</code> 是 Combine 中三大支柱之一，具体定义为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(OSX <span class="number">10.15</span>, <span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="keyword">tvOS</span> <span class="number">13.0</span>, <span class="keyword">watchOS</span> <span class="number">6.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">receive</span>&lt;<span class="type">S</span>&gt;(<span class="params">subscriber</span>: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Subscriber</span>, <span class="keyword">Self</span>.<span class="type">Failure</span> <span class="operator">==</span> <span class="type">S</span>.<span class="type">Failure</span>, <span class="keyword">Self</span>.<span class="type">Output</span> <span class="operator">==</span> <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>刚开始时我们在 SwiftUI 中声明一个新属性，也许会不知道如何选择正确的修饰词，就像刚开始接触 Flutter 时，在面对一个新创建的 <code>Widget</code> 时也不太清楚到底是有状态还是无状态，此时我的建议是「最小化原则」，一切从最小出发，在 Flutter 中不知道这个组件是不是带状态的，那就不带；在 SwiftUI 中不知道一个属性是否应该被限制在组件内，那就限制在组件内，过早的优化是一切罪恶的源头。</p>
<h3 id="Combine-中的三大支柱"><a href="#Combine-中的三大支柱" class="headerlink" title="Combine 中的三大支柱"></a>Combine 中的三大支柱</h3><ul>
<li><code>Publisher</code>，负责发布事件；</li>
<li><code>Operator</code>，负责转换事件和数据；</li>
<li><code>Subscribe</code>，负责订阅事件。</li>
</ul>
<p>这三者都是协议，且都是 <code>@propertyWrapper</code> 的具体应用。</p>
<h4 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h4><p><code>Publisher</code> 最主要的工作其实有两个:发布新的事件及其数据，以及准备好被 <code>Subscriber</code> 订阅。<code>Output</code> 及 <code>Failure</code> 定义了某个 <code>Publisher</code> 所发布的值的类型，以及可能产生的错误 的类型。</p>
<p><code>Publisher</code> 可以发布三种事件：</p>
<ol>
<li>类型为 <code>Output</code> 的新值:这代表事件流中出现了新的值；</li>
<li>类型为 <code>Failure</code> 的错误:这代表事件流中发生了问题，事件流到此终止；</li>
<li>完成事件：表示事件流中所有的元素都已经发布结束，事件流到此终止。</li>
</ol>
<p><code>Publisher</code> 的这三种事件不是必须的，也就是说，<code>Publisher</code> 可能只发一个或者一个都不发，也有可能一直在发，永远不会停止，这就是<strong>无限事件流</strong>，还有可能通过发出 <code>failure</code> 或者 <code>finished</code> 的事件表明不会再发出新的事件，这是<strong>有限事件流</strong>。</p>
<p><img src="https://i.loli.net/2019/11/12/9P1pQS7YdGgLurH.png" alt="Apple 提供了满足几乎所有场景的 Publiser"></p>
<h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><p>每个 <code>Operator</code> 的行为模式都一样：它们使用上游 <code>Publisher</code> 所发布的数据作为输入，以此产生的新的数据，然后自身成为新的 <code>Publisher</code>，并将这些新的数据作为输出，发布给下游，这样相当于得到了一个响应式的 <code>Publisher</code> 链条。</p>
<p>当链条最上端的 <code>Publisher</code> 发布某个事件后，链条中的各个 <code>Operator</code> 对事件和数据进行处理。在链条的末端我们希望最终能得到可以直接驱动 UI 状态的事件和数据。这样，终端的消费者可以直接使用这些准备好的数据。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>问题一：其不适合直接使用在当前「树形操作流」的工程里，用户对 App 的操作以目前的情况来看是一种「树形结构」，但 SwiftUI 与 Combine 的强依赖，导致了必须写大量的兼容代码去兼容 Combine 的开发哲学，但 Combine 自身的「线性开发模型」与现在的模型是冲突且难以兼容的。所以，问题不仅仅只是在对系统版本的依赖上这么简单而已。</p>
<p>问题二：目前 SwiftUI 并不具备多行文本组件，只能通过 <code>UITextView</code> 包一层，包完了以后在模拟器上一跑就卡死，只能走真机。换句话说，如果是从零开始想要搞一个大事情，全部基于 SwiftUI 去 UI 表现层上的内容，几乎不可能，非常非常痛苦。</p>
<p>问题三：部分系统提供的组件，如 <code>List</code> 很难对其做定制化，<code>Cell</code> 的分割线总是取不掉，可以通过做一些「视觉效果」规避掉这个问题，但我认为这样做过于 <code>track</code>。</p>
<p>前两个问题在我看来都是可解的，尤其是问题二，正是因为其能够完美的无缝兼容 <code>UIKit</code>，在接入成本上可以忽略不计，反而是问题一带来的影响会更大，虽然 Combine 与现在 Rx 等一套有异曲同工之处，但对已有业务的改造成本不小，比如埋点，可能会需要从以往的跟随视图的变化变为跟随数据流。</p>
<p>SwiftUI 与 SB 和 xib 一样，我认为其只是个 UI 表现层，且可以认为是用于布局等最上层的操作，对待其应该使用 SB 和 xib 的思路去使用。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a target="_blank" rel="noopener" href="https://github.com/windstormeye/Masq-iOS">Masq</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/windstormeye/SwiftGame">能否关个灯</a></p>
<h3 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/tutorials/swiftui/">SwiftUI Tutorials</a></p>
<p><a target="_blank" rel="noopener" href="https://onevcat.com/2019/06/swift-ui-firstlook/">SwiftUI 的一些初步探索 (一)</a></p>
<p><a target="_blank" rel="noopener" href="https://onevcat.com/2019/06/swift-ui-firstlook-2/">SwiftUI 的一些初步探索 (二)</a></p>
<p><a target="_blank" rel="noopener" href="https://objccn.io/products/swift-ui">SwiftUI 与 Combine 编程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QgDSuTFjwFlXzhksfgmkIQ">历时五天用 SwiftUI 做了一款 APP，阿里工程师如何做的？</a></p>
<p><a href="http://pjhubs.com/2019/08/06/swiftui01/">SwiftUI 怎么实现一个「更多菜单」？</a></p>
<p><a href="http://pjhubs.com/2019/08/12/swiftui02/">SwiftUI 怎么和 Core Data 结合？</a></p>
<h3 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h3><p><a target="_blank" rel="noopener" href="https://github.com/cx-org/CombineX">CombineX</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Dimillian/MovieSwiftUI">MovieSwiftUI</a></p>
</div><div class="tags"><a href="/tags/SwiftUI/"><i class="fa fa-tag"></i>SwiftUI</a><a href="/tags/Combine/"><i class="fa fa-tag"></i>Combine</a><a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"><i class="fa fa-tag"></i>响应式</a></div><div class="post-nav"><a class="pre" href="/2019/11/10/how-to-prepare-to-interview01/">无客户端开发经验如何准备面试？</a><a class="next" href="/2019/11/07/buildBlog01/">如何进行「云」写作</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/%E6%AF%94%E8%B5%9B/" style="font-size: 15px;">比赛</a> <a href="/tags/Cocos/" style="font-size: 15px;">Cocos</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" style="font-size: 15px;">游戏开发</a> <a href="/tags/DiDi/" style="font-size: 15px;">DiDi</a> <a href="/tags/internship/" style="font-size: 15px;">internship</a> <a href="/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/" style="font-size: 15px;">跨平台</a> <a href="/tags/Audio/" style="font-size: 15px;">Audio</a> <a href="/tags/Ping/" style="font-size: 15px;">Ping</a> <a href="/tags/%E5%BC%B9%E5%B9%95/" style="font-size: 15px;">弹幕</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/" style="font-size: 15px;">页面传值</a> <a href="/tags/HUD/" style="font-size: 15px;">HUD</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/%E5%BC%80%E6%BA%90/" style="font-size: 15px;">开源</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 15px;">项目</a> <a href="/tags/PhotosKit/" style="font-size: 15px;">PhotosKit</a> <a href="/tags/React-Native/" style="font-size: 15px;">React-Native</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/Weex/" style="font-size: 15px;">Weex</a> <a href="/tags/Apple/" style="font-size: 15px;">Apple</a> <a href="/tags/%E6%84%9F%E6%83%B3/" style="font-size: 15px;">感想</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15px;">博客</a> <a href="/tags/%E4%BA%91/" style="font-size: 15px;">云</a> <a href="/tags/%E9%9A%8F%E6%83%B3/" style="font-size: 15px;">随想</a> <a href="/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" style="font-size: 15px;">字节跳动</a> <a href="/tags/%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 15px;">月度总结</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/makefile/" style="font-size: 15px;">makefile</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 15px;">编译</a> <a href="/tags/CodeLab/" style="font-size: 15px;">CodeLab</a> <a href="/tags/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">少儿编程</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 15px;">我的大学</a> <a href="/tags/%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 15px;">回忆录</a> <a href="/tags/crash/" style="font-size: 15px;">crash</a> <a href="/tags/%E9%AA%91%E8%A1%8C/" style="font-size: 15px;">骑行</a> <a href="/tags/%E8%87%AA%E8%A1%8C%E8%BD%A6/" style="font-size: 15px;">自行车</a> <a href="/tags/fcc/" style="font-size: 15px;">fcc</a> <a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 15px;">分享</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 15px;">游戏</a> <a href="/tags/ifLab/" style="font-size: 15px;">ifLab</a> <a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 15px;">技术</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 15px;">建站</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/%E7%A7%9F%E6%88%BF/" style="font-size: 15px;">租房</a> <a href="/tags/iBistu/" style="font-size: 15px;">iBistu</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 15px;">编译原理</a> <a href="/tags/%E7%9D%A1%E9%AD%94/" style="font-size: 15px;">睡魔</a> <a href="/tags/Netflix/" style="font-size: 15px;">Netflix</a> <a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 15px;">摄影</a> <a href="/tags/%E4%BD%9C%E5%93%81/" style="font-size: 15px;">作品</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 15px;">开发日志</a> <a href="/tags/App/" style="font-size: 15px;">App</a> <a href="/tags/%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/" style="font-size: 15px;">产品思考</a> <a href="/tags/Playground/" style="font-size: 15px;">Playground</a> <a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 15px;">工作</a> <a href="/tags/SwiftUI/" style="font-size: 15px;">SwiftUI</a> <a href="/tags/%E5%BD%B1%E8%A7%86%E5%89%A7/" style="font-size: 15px;">影视剧</a> <a href="/tags/WWDC/" style="font-size: 15px;">WWDC</a> <a href="/tags/%E5%AD%97%E8%8A%82/" style="font-size: 15px;">字节</a> <a href="/tags/%E8%B7%91%E6%AD%A5/" style="font-size: 15px;">跑步</a> <a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 15px;">马拉松</a> <a href="/tags/%E8%BF%90%E5%8A%A8/" style="font-size: 15px;">运动</a> <a href="/tags/%E8%B6%8A%E9%87%8E%E8%B7%91/" style="font-size: 15px;">越野跑</a> <a href="/tags/%E6%84%9F%E8%B0%A2/" style="font-size: 15px;">感谢</a> <a href="/tags/%E6%BB%B4%E6%BB%B4/" style="font-size: 15px;">滴滴</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 15px;">思考</a> <a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 15px;">旅行</a> <a href="/tags/%E6%84%9F%E6%80%A7/" style="font-size: 15px;">感性</a> <a href="/tags/%E9%9D%92%E5%B2%9B/" style="font-size: 15px;">青岛</a> <a href="/tags/%E5%BE%92%E6%AD%A5/" style="font-size: 15px;">徒步</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/WatchOS/" style="font-size: 15px;">WatchOS</a> <a href="/tags/Combine/" style="font-size: 15px;">Combine</a> <a href="/tags/django/" style="font-size: 15px;">django</a> <a href="/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 15px;">实习</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 15px;">微信</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a> <a href="/tags/%E6%90%9E%E4%BA%8B%E6%83%85%E7%B3%BB%E5%88%97/" style="font-size: 15px;">搞事情系列</a> <a href="/tags/%E4%B8%83%E7%89%9B%E4%BA%91/" style="font-size: 15px;">七牛云</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/Junit/" style="font-size: 15px;">Junit</a> <a href="/tags/log4j/" style="font-size: 15px;">log4j</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Spring-MVC/" style="font-size: 15px;">Spring MVC</a> <a href="/tags/%E5%9B%BD%E9%99%85%E5%8C%96/" style="font-size: 15px;">国际化</a> <a href="/tags/%E6%BC%94%E8%AE%B2/" style="font-size: 15px;">演讲</a> <a href="/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/" style="font-size: 15px;">即时通讯</a> <a href="/tags/side-project/" style="font-size: 15px;">side project</a> <a href="/tags/Qt/" style="font-size: 15px;">Qt</a> <a href="/tags/C-%E8%B7%A8%E7%AB%AF/" style="font-size: 15px;">C++ 跨端</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" style="font-size: 15px;">响应式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 联系我</i></div><ul></ul><a href="https://github.com/windstormeye" title="GitHub - PJHubs" target="_blank">GitHub - PJHubs</a><ul></ul><a href="https://www.xiaohongshu.com/user/profile/5f2cd0360000000001001470" title="小红书 - PJHubs" target="_blank">小红书 - PJHubs</a><ul></ul><a href="https://www.instagram.com/pjhubs/" title="Instagram - PJHubs" target="_blank">Instagram - PJHubs</a><ul></ul><a href="https://space.bilibili.com/25392474" title="BiliBili - PJHubs" target="_blank">BiliBili - PJHubs</a><ul></ul><a href="https://twitter.com/wengpeijun" title="Twitter - PJHubs" target="_blank">Twitter - PJHubs</a><ul></ul><a href="." title="邮箱 - 877302410@qq.com" target="_blank">邮箱 - 877302410@qq.com</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 PJHubs</div></div></div><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>